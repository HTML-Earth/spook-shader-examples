<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>mix.spook</title>
    <style>
      body {
          margin: 0;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>


  <!-- VERTEX -->
  
  <script id="vs" type="notjs">
#version 300 es
in vec4 position;

void main() {
  gl_Position = position;
}
  </script>



  <!-- FRAGMENT -->

  <script id="fs" type="notjs">#version 300 es
// mix.spook
// Compiled with Spook Compiler 
// https://github.com/HTML-Earth/Spook-Compiler

precision mediump float;

out vec4 fragColor;

uniform vec2 iResolution;
uniform float iTime;

const float PI = 3.1415926535897932384626433832795;

struct Circle {
	float radius;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};
struct Rectangle {
	vec2 size;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};
struct Polygon {
	vec2 points[16];
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};

bool CircleCheck(vec2 point, Circle circle);
bool RectangleCheck(vec2 point, Rectangle rec);
bool PolygonCheck(vec2 point, Polygon poly, int amt);
mat2 rotate2D(float angle);
mat2 scale2D(vec2 scale);

void main() {
vec2 fragCoord = gl_FragCoord.xy;
	// Variable Declarations
	float sway = sin(iTime*0.20000000298023224)*50.0;

	float hover = sin(iTime)*15.0;

	vec4 bgColor = vec4(0.30000001192092896, 0.30000001192092896, 0.30000001192092896, 1.0);

	float hLineHeight = iResolution.y/2.0;

	float repeatingTime = mod(iTime, 1.0);

	float dotSize = 15.0;

	float dotX = repeatingTime*iResolution.x*0.25;

	float dotX2 = repeatingTime*iResolution.x*0.25+iResolution.x*0.25;

	float unitHeight = iResolution.y/4.0;

	float dotX3 = repeatingTime*iResolution.x*0.25+iResolution.x*0.5;

	float dotX4 = repeatingTime*iResolution.x*0.25+iResolution.x*0.75;

	float signValue = sign(sin(repeatingTime*6.0));

	vec4 signColor = vec4(signValue, signValue, signValue, 1.0);

	float moreMath = acos(acosh(cosh(asin(asinh(sinh(atan(atanh(tanh(iTime)))))))));

	float FxPos = iResolution.x/2.0;

	float FyPos = iResolution.y/2.0+200.0;

	vec4 whiteTransparent = vec4(1.0, 1.0, 1.0, 0.5);

	float blinkMove = sin(iTime)*80.0;

	vec2 point1 = vec2(0.0, 0.0);

	vec2 point3 = vec2(250.0, 0.0);

	vec2 point4 = vec2(250.0, 25.0);

	vec2 point5 = vec2(125.0, 60.0);

	vec2 point6 = vec2(0.0, 25.0);

	vec2 point2 = vec2(125.0, 10.0);

	float xPos = 150.0+sway;

	float yPos = 210.0+hover;

	float hoverTips = sin(iTime)*-5.0;

	float swayFace = -sin(iTime*0.20000000298023224-2.0)*-8.0;

	float hoverEyes = sin(iTime-0.10000000149011612)*5.0;

	float hoverMouf = sin(iTime-0.20000000298023224)*10.0;

	float rotation = sin(iTime)*15.0;

	float circleScale = max(sin(iTime*0.25), 0.25)*3.0;

	vec2 p1 = vec2(-100.0, 10.0);

	vec2 p2 = vec2(10.0, 100.0);

	vec2 p3 = vec2(20.0, -10.0);

	vec2 p4 = vec2(-20.0, -20.0);

	// Object Declarations
	Rectangle hLine = Rectangle(
		vec2(iResolution.x, 5.0),
		vec2(iResolution.x/2.0+0.0, hLineHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.5, 1.0)
	);

	Rectangle vLine1 = Rectangle(
		vec2(10.0, iResolution.y),
		vec2(0.0+0.0, hLineHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.5, 1.0)
	);

	Rectangle vLine2 = Rectangle(
		vec2(5.0, iResolution.y),
		vec2(iResolution.x/4.0+0.0, hLineHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.5, 1.0)
	);

	Rectangle vLine3 = Rectangle(
		vec2(5.0, iResolution.y),
		vec2(iResolution.x-iResolution.x/2.0+0.0, hLineHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.5, 1.0)
	);

	Rectangle vLine4 = Rectangle(
		vec2(5.0, iResolution.y),
		vec2(iResolution.x-iResolution.x/4.0+0.0, hLineHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.5, 1.0)
	);

	Circle expDot = Circle(
		dotSize,
		vec2(dotX+0.0, hLineHeight+exp(repeatingTime*8.0)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Circle exp2Dot = Circle(
		dotSize/2.0,
		vec2(dotX+0.0, hLineHeight+exp2(repeatingTime*8.0)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 1.0, 1.0, 1.0)
	);

	Circle logDot = Circle(
		dotSize,
		vec2(dotX2+0.0, hLineHeight+log(repeatingTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.59, 0.29, 0.0, 1.0)
	);

	Circle log2Dot = Circle(
		dotSize/2.0,
		vec2(dotX2+0.0, hLineHeight+log2(repeatingTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.5, 0.0, 1.0)
	);

	Circle powDot = Circle(
		dotSize,
		vec2(dotX3+0.0, hLineHeight+pow(repeatingTime*2.0, 2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Circle sqrtDot = Circle(
		dotSize/2.0,
		vec2(dotX3+0.0, hLineHeight+sqrt(repeatingTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Circle inversesqrtDot = Circle(
		dotSize/3.0,
		vec2(dotX3+0.0, hLineHeight+inversesqrt(repeatingTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.75, 0.8, 1.0)
	);

	Circle smoothstepDot = Circle(
		dotSize,
		vec2(dotX4+0.0, hLineHeight+smoothstep(1.0, 3.0, repeatingTime*4.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.5, 0.0, 1.0)
	);

	Circle stepDot = Circle(
		dotSize/2.0,
		vec2(dotX4+0.0, hLineHeight+step(2.0, repeatingTime*4.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 1.0, 0.0, 1.0)
	);

	Circle roundDot = Circle(
		dotSize,
		vec2(dotX+0.0, hLineHeight+round(repeatingTime*5.0)*30.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Circle roundEvenDot = Circle(
		dotSize/2.0,
		vec2(dotX+0.0, hLineHeight+roundEven(repeatingTime*5.0)*30.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 1.0, 1.0, 1.0)
	);

	Circle fractDot = Circle(
		dotSize/2.0,
		vec2(dotX+0.0, hLineHeight-fract(repeatingTime*5.0)*30.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 1.0, 0.83, 1.0)
	);

	Circle clampDot = Circle(
		dotSize,
		vec2(dotX2+0.0, hLineHeight+clamp(sin(repeatingTime*6.0), (-0.25), 0.5)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.59, 0.29, 0.0, 1.0)
	);

	Circle truncDot = Circle(
		dotSize/2.0,
		vec2(dotX2+0.0, hLineHeight+trunc(sin(repeatingTime*6.0)*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.5, 0.0, 1.0)
	);

	Circle ceilDot = Circle(
		dotSize/2.0,
		vec2(dotX3+0.0, hLineHeight+ceil(sin(repeatingTime*6.0)*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle floorDot = Circle(
		dotSize/2.0,
		vec2(dotX3+0.0, hLineHeight+floor(sin(repeatingTime*6.0)*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle minDot = Circle(
		dotSize,
		vec2(dotX3+0.0, hLineHeight+min(sin(repeatingTime*6.0)*2.0, 0.5)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle maxDot = Circle(
		dotSize,
		vec2(dotX3+0.0, hLineHeight+max(sin(repeatingTime*6.0)*2.0, -0.5)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Rectangle signRect = Rectangle(
		vec2(iResolution.x*0.23999999463558197, 10.0),
		vec2(iResolution.x*0.625+0.0, hLineHeight+signValue*iResolution.y/2.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(signColor)
	);

	Circle mixDot = Circle(
		dotSize,
		vec2(dotX4+0.0, hLineHeight+mix(60.0, -5.0, repeatingTime)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Circle sineDot = Circle(
		dotSize,
		vec2(dotX+0.0, hLineHeight+sin(iTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Circle absSineDot = Circle(
		dotSize/2.0,
		vec2(dotX+0.0, hLineHeight+abs(sin(iTime*2.0)*unitHeight)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 1.0, 1.0, 1.0)
	);

	Circle cosineDot = Circle(
		dotSize,
		vec2(dotX2+0.0, hLineHeight+cos(iTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.59, 0.29, 0.0, 1.0)
	);

	Circle absCosineDot = Circle(
		dotSize/2.0,
		vec2(dotX2+0.0, hLineHeight+abs(cos(iTime*2.0)*unitHeight)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.5, 0.0, 1.0)
	);

	Circle tangentDot = Circle(
		dotSize,
		vec2(dotX3+0.0, hLineHeight+tan(iTime*2.0)*unitHeight+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Circle absTangentDot = Circle(
		dotSize/2.0,
		vec2(dotX3+0.0, hLineHeight+abs(tan(iTime*2.0)*unitHeight)+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.75, 0.8, 1.0)
	);

	Circle mathDot = Circle(
		dotSize,
		vec2(moreMath+0.0, 0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle bag1 = Circle(
		100.0,
		vec2(FxPos-150.0+0.0+0.0, FyPos-10.0+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Circle bag2 = Circle(
		100.0,
		vec2(FxPos+150.0+0.0+0.0, FyPos-10.0+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Circle shine1 = Circle(
		30.0,
		vec2(20.0+20.0+cos(iTime)*20.0+FxPos-150.0+0.0+0.0, 30.0+sin(iTime)*20.0+FyPos+0.0+0.0),
		vec2(0.5, 1.0),
		0.0,
		vec4(whiteTransparent)
	);

	Circle circleEye1 = Circle(
		55.0,
		vec2(20.0+cos(iTime)*20.0+FxPos-150.0+0.0+0.0, sin(iTime)*20.0+FyPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle Fcircle1 = Circle(
		100.0,
		vec2(FxPos-150.0+0.0+0.0, FyPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle shine2 = Circle(
		30.0,
		vec2(20.0+-20.0+cos(iTime)*20.0+FxPos+150.0+0.0+0.0, 30.0+sin(iTime)*20.0+FyPos+0.0+0.0),
		vec2(0.5, 1.0),
		0.0,
		vec4(whiteTransparent)
	);

	Circle circleEye2 = Circle(
		55.0,
		vec2(-20.0+cos(iTime)*20.0+FxPos+150.0+0.0+0.0, sin(iTime)*20.0+FyPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle Fcircle2 = Circle(
		100.0,
		vec2(FxPos+150.0+0.0+0.0, FyPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle middle = Circle(
		10.0,
		vec2(0.0+0.0, 0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 0.0)
	);

	Rectangle eyelid1 = Rectangle(
		vec2(200.0, 300.0),
		vec2(150.0+FxPos+0.0, 0.0+FyPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Rectangle eyelid2 = Rectangle(
		vec2(200.0, 300.0),
		vec2(-150.0+FxPos+0.0, 0.0+FyPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Rectangle Frec1 = Rectangle(
		vec2(200.0, 305.0),
		vec2(150.0+FxPos+0.0, 15.0+FyPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(bgColor)
	);

	Rectangle Frec2 = Rectangle(
		vec2(200.0, 305.0),
		vec2(-150.0+FxPos+0.0, 15.0+FyPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(bgColor)
	);

	Circle mover = Circle(
		10.0,
		vec2(FxPos+0.0, FyPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 0.0)
	);

	Circle tongue = Circle(
		30.0,
		vec2(0.0+FxPos+0.0, -35.0+FyPos-120.0+0.0),
		vec2(1.0, 0.6000000238418579),
		0.0,
		vec4(1.0, 0.0, 0.0, 1.0)
	);

	Circle mouth = Circle(
		50.0,
		vec2(FxPos+0.0, FyPos-120.0+0.0),
		vec2(1.0, 0.4000000059604645),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Polygon eyeBrow1 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(250.0, 25.0),
			vec2(125.0, 60.0),
			vec2(0.0, 25.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(FxPos-275.0+0.0, FyPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Polygon eyeBrow2 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(250.0, 25.0),
			vec2(125.0, 60.0),
			vec2(0.0, 25.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(FxPos+25.0+0.0, FyPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Polygon eyeBrowFix1 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(125.0, 10.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(FxPos-275.0+0.0, FyPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Polygon eyeBrowFix2 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(125.0, 10.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(FxPos+25.0+0.0, FyPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Circle top1 = Circle(
		40.0,
		vec2(30.0+xPos+0.0, 60.0+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle top2 = Circle(
		40.0,
		vec2(0.0+xPos+0.0, 50.0+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle mouf = Circle(
		90.0,
		vec2(50.0+xPos+0.0, -60.0+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip1 = Circle(
		15.0,
		vec2(-30.0+xPos+0.0, -112.0+hoverTips+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip2 = Circle(
		15.0,
		vec2(-15.0+xPos+0.0, -132.0+hoverTips+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip3 = Circle(
		15.0,
		vec2(10.0+xPos+0.0, -142.0+hoverTips+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip4 = Circle(
		15.0,
		vec2(35.0+xPos+0.0, -147.0+hoverTips+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip5 = Circle(
		15.0,
		vec2(60.0+xPos+0.0, -152.0+hoverTips+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle eye1 = Circle(
		20.0,
		vec2(swayFace+xPos+0.0, 30.0+hoverEyes+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle eye2 = Circle(
		15.0,
		vec2(swayFace+40.0+xPos+0.0, 40.0+hoverEyes+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle moufHole = Circle(
		35.0,
		vec2(swayFace+90.0+xPos+0.0, -60.0+hoverMouf+yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle hed = Circle(
		80.0,
		vec2(xPos+0.0, yPos+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle circle5 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec5 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle4 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec4 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle3 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec3 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle2 = Circle(
		25.0,
		vec2(50.0+50.0+1100.0+0.0, 50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec2 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+1100.0+0.0, 50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle1 = Circle(
		25.0,
		vec2(50.0+1100.0+0.0, 50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec1 = Rectangle(
		vec2(50.0, 50.0),
		vec2(1100.0+0.0, 50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Polygon poly = Polygon(
		vec2[16](
			vec2(-100.0, 10.0),
			vec2(10.0, 100.0),
			vec2(20.0, -10.0),
			vec2(-20.0, -20.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(sin(iTime)*100.0+200.0+0.0, cos(iTime*4.0)*100.0+720.0+0.0),
		vec2(1.0, 1.0),
		sin(iTime)*180.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	// Checks and Drawing
	fragColor = vec4(bgColor);


	vec2 hLineSpace = fragCoord;
	hLineSpace -= hLine.pos;
	hLineSpace = rotate2D(hLine.rot) * hLineSpace;
	hLineSpace = scale2D(hLine.scale) * hLineSpace;
	hLineSpace += hLine.pos;
	if (false ^^ RectangleCheck(hLineSpace, hLine)) {
		fragColor = hLine.color;
	}

	vec2 vLine1Space = fragCoord;
	vLine1Space -= vLine1.pos;
	vLine1Space = rotate2D(vLine1.rot) * vLine1Space;
	vLine1Space = scale2D(vLine1.scale) * vLine1Space;
	vLine1Space += vLine1.pos;
	if (false ^^ RectangleCheck(vLine1Space, vLine1)) {
		fragColor = vLine1.color;
	}

	vec2 vLine2Space = fragCoord;
	vLine2Space -= vLine2.pos;
	vLine2Space = rotate2D(vLine2.rot) * vLine2Space;
	vLine2Space = scale2D(vLine2.scale) * vLine2Space;
	vLine2Space += vLine2.pos;
	if (false ^^ RectangleCheck(vLine2Space, vLine2)) {
		fragColor = vLine2.color;
	}

	vec2 vLine3Space = fragCoord;
	vLine3Space -= vLine3.pos;
	vLine3Space = rotate2D(vLine3.rot) * vLine3Space;
	vLine3Space = scale2D(vLine3.scale) * vLine3Space;
	vLine3Space += vLine3.pos;
	if (false ^^ RectangleCheck(vLine3Space, vLine3)) {
		fragColor = vLine3.color;
	}

	vec2 vLine4Space = fragCoord;
	vLine4Space -= vLine4.pos;
	vLine4Space = rotate2D(vLine4.rot) * vLine4Space;
	vLine4Space = scale2D(vLine4.scale) * vLine4Space;
	vLine4Space += vLine4.pos;
	if (false ^^ RectangleCheck(vLine4Space, vLine4)) {
		fragColor = vLine4.color;
	}

	vec2 expDotSpace = fragCoord;
	expDotSpace -= expDot.pos;
	expDotSpace = rotate2D(expDot.rot) * expDotSpace;
	expDotSpace = scale2D(expDot.scale) * expDotSpace;
	expDotSpace += expDot.pos;
	if (false ^^ CircleCheck(expDotSpace, expDot)) {
		fragColor = expDot.color;
	}

	vec2 exp2DotSpace = fragCoord;
	exp2DotSpace -= exp2Dot.pos;
	exp2DotSpace = rotate2D(exp2Dot.rot) * exp2DotSpace;
	exp2DotSpace = scale2D(exp2Dot.scale) * exp2DotSpace;
	exp2DotSpace += exp2Dot.pos;
	if (false ^^ CircleCheck(exp2DotSpace, exp2Dot)) {
		fragColor = exp2Dot.color;
	}

	vec2 logDotSpace = fragCoord;
	logDotSpace -= logDot.pos;
	logDotSpace = rotate2D(logDot.rot) * logDotSpace;
	logDotSpace = scale2D(logDot.scale) * logDotSpace;
	logDotSpace += logDot.pos;
	if (false ^^ CircleCheck(logDotSpace, logDot)) {
		fragColor = logDot.color;
	}

	vec2 log2DotSpace = fragCoord;
	log2DotSpace -= log2Dot.pos;
	log2DotSpace = rotate2D(log2Dot.rot) * log2DotSpace;
	log2DotSpace = scale2D(log2Dot.scale) * log2DotSpace;
	log2DotSpace += log2Dot.pos;
	if (false ^^ CircleCheck(log2DotSpace, log2Dot)) {
		fragColor = log2Dot.color;
	}

	vec2 powDotSpace = fragCoord;
	powDotSpace -= powDot.pos;
	powDotSpace = rotate2D(powDot.rot) * powDotSpace;
	powDotSpace = scale2D(powDot.scale) * powDotSpace;
	powDotSpace += powDot.pos;
	if (false ^^ CircleCheck(powDotSpace, powDot)) {
		fragColor = powDot.color;
	}

	vec2 sqrtDotSpace = fragCoord;
	sqrtDotSpace -= sqrtDot.pos;
	sqrtDotSpace = rotate2D(sqrtDot.rot) * sqrtDotSpace;
	sqrtDotSpace = scale2D(sqrtDot.scale) * sqrtDotSpace;
	sqrtDotSpace += sqrtDot.pos;
	if (false ^^ CircleCheck(sqrtDotSpace, sqrtDot)) {
		fragColor = sqrtDot.color;
	}

	vec2 inversesqrtDotSpace = fragCoord;
	inversesqrtDotSpace -= inversesqrtDot.pos;
	inversesqrtDotSpace = rotate2D(inversesqrtDot.rot) * inversesqrtDotSpace;
	inversesqrtDotSpace = scale2D(inversesqrtDot.scale) * inversesqrtDotSpace;
	inversesqrtDotSpace += inversesqrtDot.pos;
	if (false ^^ CircleCheck(inversesqrtDotSpace, inversesqrtDot)) {
		fragColor = inversesqrtDot.color;
	}

	vec2 smoothstepDotSpace = fragCoord;
	smoothstepDotSpace -= smoothstepDot.pos;
	smoothstepDotSpace = rotate2D(smoothstepDot.rot) * smoothstepDotSpace;
	smoothstepDotSpace = scale2D(smoothstepDot.scale) * smoothstepDotSpace;
	smoothstepDotSpace += smoothstepDot.pos;
	if (false ^^ CircleCheck(smoothstepDotSpace, smoothstepDot)) {
		fragColor = smoothstepDot.color;
	}

	vec2 stepDotSpace = fragCoord;
	stepDotSpace -= stepDot.pos;
	stepDotSpace = rotate2D(stepDot.rot) * stepDotSpace;
	stepDotSpace = scale2D(stepDot.scale) * stepDotSpace;
	stepDotSpace += stepDot.pos;
	if (false ^^ CircleCheck(stepDotSpace, stepDot)) {
		fragColor = stepDot.color;
	}

	vec2 roundDotSpace = fragCoord;
	roundDotSpace -= roundDot.pos;
	roundDotSpace = rotate2D(roundDot.rot) * roundDotSpace;
	roundDotSpace = scale2D(roundDot.scale) * roundDotSpace;
	roundDotSpace += roundDot.pos;
	if (false ^^ CircleCheck(roundDotSpace, roundDot)) {
		fragColor = roundDot.color;
	}

	vec2 roundEvenDotSpace = fragCoord;
	roundEvenDotSpace -= roundEvenDot.pos;
	roundEvenDotSpace = rotate2D(roundEvenDot.rot) * roundEvenDotSpace;
	roundEvenDotSpace = scale2D(roundEvenDot.scale) * roundEvenDotSpace;
	roundEvenDotSpace += roundEvenDot.pos;
	if (false ^^ CircleCheck(roundEvenDotSpace, roundEvenDot)) {
		fragColor = roundEvenDot.color;
	}

	vec2 fractDotSpace = fragCoord;
	fractDotSpace -= fractDot.pos;
	fractDotSpace = rotate2D(fractDot.rot) * fractDotSpace;
	fractDotSpace = scale2D(fractDot.scale) * fractDotSpace;
	fractDotSpace += fractDot.pos;
	if (false ^^ CircleCheck(fractDotSpace, fractDot)) {
		fragColor = fractDot.color;
	}

	vec2 clampDotSpace = fragCoord;
	clampDotSpace -= clampDot.pos;
	clampDotSpace = rotate2D(clampDot.rot) * clampDotSpace;
	clampDotSpace = scale2D(clampDot.scale) * clampDotSpace;
	clampDotSpace += clampDot.pos;
	if (false ^^ CircleCheck(clampDotSpace, clampDot)) {
		fragColor = clampDot.color;
	}

	vec2 truncDotSpace = fragCoord;
	truncDotSpace -= truncDot.pos;
	truncDotSpace = rotate2D(truncDot.rot) * truncDotSpace;
	truncDotSpace = scale2D(truncDot.scale) * truncDotSpace;
	truncDotSpace += truncDot.pos;
	if (false ^^ CircleCheck(truncDotSpace, truncDot)) {
		fragColor = truncDot.color;
	}

	vec2 ceilDotSpace = fragCoord;
	ceilDotSpace -= ceilDot.pos;
	ceilDotSpace = rotate2D(ceilDot.rot) * ceilDotSpace;
	ceilDotSpace = scale2D(ceilDot.scale) * ceilDotSpace;
	ceilDotSpace += ceilDot.pos;
	if (false ^^ CircleCheck(ceilDotSpace, ceilDot)) {
		fragColor = ceilDot.color;
	}

	vec2 floorDotSpace = fragCoord;
	floorDotSpace -= floorDot.pos;
	floorDotSpace = rotate2D(floorDot.rot) * floorDotSpace;
	floorDotSpace = scale2D(floorDot.scale) * floorDotSpace;
	floorDotSpace += floorDot.pos;
	if (false ^^ CircleCheck(floorDotSpace, floorDot)) {
		fragColor = floorDot.color;
	}

	vec2 minDotSpace = fragCoord;
	minDotSpace -= minDot.pos;
	minDotSpace = rotate2D(minDot.rot) * minDotSpace;
	minDotSpace = scale2D(minDot.scale) * minDotSpace;
	minDotSpace += minDot.pos;
	if (false ^^ CircleCheck(minDotSpace, minDot)) {
		fragColor = minDot.color;
	}

	vec2 maxDotSpace = fragCoord;
	maxDotSpace -= maxDot.pos;
	maxDotSpace = rotate2D(maxDot.rot) * maxDotSpace;
	maxDotSpace = scale2D(maxDot.scale) * maxDotSpace;
	maxDotSpace += maxDot.pos;
	if (false ^^ CircleCheck(maxDotSpace, maxDot)) {
		fragColor = maxDot.color;
	}

	vec2 signRectSpace = fragCoord;
	signRectSpace -= signRect.pos;
	signRectSpace = rotate2D(signRect.rot) * signRectSpace;
	signRectSpace = scale2D(signRect.scale) * signRectSpace;
	signRectSpace += signRect.pos;
	if (false ^^ RectangleCheck(signRectSpace, signRect)) {
		fragColor = mix(fragColor, signRect.color, signRect.color.a);
	}

	vec2 mixDotSpace = fragCoord;
	mixDotSpace -= mixDot.pos;
	mixDotSpace = rotate2D(mixDot.rot) * mixDotSpace;
	mixDotSpace = scale2D(mixDot.scale) * mixDotSpace;
	mixDotSpace += mixDot.pos;
	if (false ^^ CircleCheck(mixDotSpace, mixDot)) {
		fragColor = mixDot.color;
	}

	vec2 sineDotSpace = fragCoord;
	sineDotSpace -= sineDot.pos;
	sineDotSpace = rotate2D(sineDot.rot) * sineDotSpace;
	sineDotSpace = scale2D(sineDot.scale) * sineDotSpace;
	sineDotSpace += sineDot.pos;
	if (false ^^ CircleCheck(sineDotSpace, sineDot)) {
		fragColor = sineDot.color;
	}

	vec2 absSineDotSpace = fragCoord;
	absSineDotSpace -= absSineDot.pos;
	absSineDotSpace = rotate2D(absSineDot.rot) * absSineDotSpace;
	absSineDotSpace = scale2D(absSineDot.scale) * absSineDotSpace;
	absSineDotSpace += absSineDot.pos;
	if (false ^^ CircleCheck(absSineDotSpace, absSineDot)) {
		fragColor = absSineDot.color;
	}

	vec2 cosineDotSpace = fragCoord;
	cosineDotSpace -= cosineDot.pos;
	cosineDotSpace = rotate2D(cosineDot.rot) * cosineDotSpace;
	cosineDotSpace = scale2D(cosineDot.scale) * cosineDotSpace;
	cosineDotSpace += cosineDot.pos;
	if (false ^^ CircleCheck(cosineDotSpace, cosineDot)) {
		fragColor = cosineDot.color;
	}

	vec2 absCosineDotSpace = fragCoord;
	absCosineDotSpace -= absCosineDot.pos;
	absCosineDotSpace = rotate2D(absCosineDot.rot) * absCosineDotSpace;
	absCosineDotSpace = scale2D(absCosineDot.scale) * absCosineDotSpace;
	absCosineDotSpace += absCosineDot.pos;
	if (false ^^ CircleCheck(absCosineDotSpace, absCosineDot)) {
		fragColor = absCosineDot.color;
	}

	vec2 tangentDotSpace = fragCoord;
	tangentDotSpace -= tangentDot.pos;
	tangentDotSpace = rotate2D(tangentDot.rot) * tangentDotSpace;
	tangentDotSpace = scale2D(tangentDot.scale) * tangentDotSpace;
	tangentDotSpace += tangentDot.pos;
	if (false ^^ CircleCheck(tangentDotSpace, tangentDot)) {
		fragColor = tangentDot.color;
	}

	vec2 absTangentDotSpace = fragCoord;
	absTangentDotSpace -= absTangentDot.pos;
	absTangentDotSpace = rotate2D(absTangentDot.rot) * absTangentDotSpace;
	absTangentDotSpace = scale2D(absTangentDot.scale) * absTangentDotSpace;
	absTangentDotSpace += absTangentDot.pos;
	if (false ^^ CircleCheck(absTangentDotSpace, absTangentDot)) {
		fragColor = absTangentDot.color;
	}

	vec2 mathDotSpace = fragCoord;
	mathDotSpace -= mathDot.pos;
	mathDotSpace = rotate2D(mathDot.rot) * mathDotSpace;
	mathDotSpace = scale2D(mathDot.scale) * mathDotSpace;
	mathDotSpace += mathDot.pos;
	if (false ^^ CircleCheck(mathDotSpace, mathDot)) {
		fragColor = mathDot.color;
	}

	vec2 middleSpace = fragCoord;
	middleSpace -= middle.pos;
	middleSpace = rotate2D(middle.rot) * middleSpace;
	middleSpace = scale2D(middle.scale) * middleSpace;
	middleSpace += middle.pos;
	if (false ^^ CircleCheck(middleSpace, middle)) {
		fragColor = mix(fragColor, middle.color, middle.color.a);
	}

	vec2 bag1Space = middleSpace;
	bag1Space -= bag1.pos;
	bag1Space = rotate2D(bag1.rot) * bag1Space;
	bag1Space = scale2D(bag1.scale) * bag1Space;
	bag1Space += bag1.pos;
	if (false ^^ CircleCheck(bag1Space, bag1)) {
		fragColor = bag1.color;
	}

	vec2 bag2Space = middleSpace;
	bag2Space -= bag2.pos;
	bag2Space = rotate2D(bag2.rot) * bag2Space;
	bag2Space = scale2D(bag2.scale) * bag2Space;
	bag2Space += bag2.pos;
	if (false ^^ CircleCheck(bag2Space, bag2)) {
		fragColor = bag2.color;
	}

	vec2 Fcircle1Space = middleSpace;
	Fcircle1Space -= Fcircle1.pos;
	Fcircle1Space = rotate2D(Fcircle1.rot) * Fcircle1Space;
	Fcircle1Space = scale2D(Fcircle1.scale) * Fcircle1Space;
	Fcircle1Space += Fcircle1.pos;
	if (false ^^ CircleCheck(Fcircle1Space, Fcircle1)) {
		fragColor = Fcircle1.color;
	}

	vec2 circleEye1Space = Fcircle1Space;
	circleEye1Space -= circleEye1.pos;
	circleEye1Space = rotate2D(circleEye1.rot) * circleEye1Space;
	circleEye1Space = scale2D(circleEye1.scale) * circleEye1Space;
	circleEye1Space += circleEye1.pos;
	if (false ^^ CircleCheck(circleEye1Space, circleEye1)) {
		fragColor = circleEye1.color;
	}

	vec2 shine1Space = circleEye1Space;
	shine1Space -= shine1.pos;
	shine1Space = rotate2D(shine1.rot) * shine1Space;
	shine1Space = scale2D(shine1.scale) * shine1Space;
	shine1Space += shine1.pos;
	if (false ^^ CircleCheck(shine1Space, shine1)) {
		fragColor = mix(fragColor, shine1.color, shine1.color.a);
	}

	vec2 Fcircle2Space = middleSpace;
	Fcircle2Space -= Fcircle2.pos;
	Fcircle2Space = rotate2D(Fcircle2.rot) * Fcircle2Space;
	Fcircle2Space = scale2D(Fcircle2.scale) * Fcircle2Space;
	Fcircle2Space += Fcircle2.pos;
	if (false ^^ CircleCheck(Fcircle2Space, Fcircle2)) {
		fragColor = Fcircle2.color;
	}

	vec2 circleEye2Space = Fcircle2Space;
	circleEye2Space -= circleEye2.pos;
	circleEye2Space = rotate2D(circleEye2.rot) * circleEye2Space;
	circleEye2Space = scale2D(circleEye2.scale) * circleEye2Space;
	circleEye2Space += circleEye2.pos;
	if (false ^^ CircleCheck(circleEye2Space, circleEye2)) {
		fragColor = circleEye2.color;
	}

	vec2 shine2Space = circleEye2Space;
	shine2Space -= shine2.pos;
	shine2Space = rotate2D(shine2.rot) * shine2Space;
	shine2Space = scale2D(shine2.scale) * shine2Space;
	shine2Space += shine2.pos;
	if (false ^^ CircleCheck(shine2Space, shine2)) {
		fragColor = mix(fragColor, shine2.color, shine2.color.a);
	}

	vec2 moverSpace = fragCoord;
	moverSpace -= mover.pos;
	moverSpace = rotate2D(mover.rot) * moverSpace;
	moverSpace = scale2D(mover.scale) * moverSpace;
	moverSpace += mover.pos;
	if (false ^^ CircleCheck(moverSpace, mover)) {
		fragColor = mix(fragColor, mover.color, mover.color.a);
	}

	vec2 eyelid1Space = moverSpace;
	eyelid1Space -= eyelid1.pos;
	eyelid1Space = rotate2D(eyelid1.rot) * eyelid1Space;
	eyelid1Space = scale2D(eyelid1.scale) * eyelid1Space;
	eyelid1Space += eyelid1.pos;
	if (false ^^ RectangleCheck(eyelid1Space, eyelid1)) {
		fragColor = eyelid1.color;
	}

	vec2 eyelid2Space = moverSpace;
	eyelid2Space -= eyelid2.pos;
	eyelid2Space = rotate2D(eyelid2.rot) * eyelid2Space;
	eyelid2Space = scale2D(eyelid2.scale) * eyelid2Space;
	eyelid2Space += eyelid2.pos;
	if (false ^^ RectangleCheck(eyelid2Space, eyelid2)) {
		fragColor = eyelid2.color;
	}

	vec2 Frec1Space = moverSpace;
	Frec1Space -= Frec1.pos;
	Frec1Space = rotate2D(Frec1.rot) * Frec1Space;
	Frec1Space = scale2D(Frec1.scale) * Frec1Space;
	Frec1Space += Frec1.pos;
	if (false ^^ RectangleCheck(Frec1Space, Frec1)) {
		fragColor = mix(fragColor, Frec1.color, Frec1.color.a);
	}

	vec2 Frec2Space = moverSpace;
	Frec2Space -= Frec2.pos;
	Frec2Space = rotate2D(Frec2.rot) * Frec2Space;
	Frec2Space = scale2D(Frec2.scale) * Frec2Space;
	Frec2Space += Frec2.pos;
	if (false ^^ RectangleCheck(Frec2Space, Frec2)) {
		fragColor = mix(fragColor, Frec2.color, Frec2.color.a);
	}

	vec2 mouthSpace = fragCoord;
	mouthSpace -= mouth.pos;
	mouthSpace = rotate2D(mouth.rot) * mouthSpace;
	mouthSpace = scale2D(mouth.scale) * mouthSpace;
	mouthSpace += mouth.pos;
	if (false ^^ CircleCheck(mouthSpace, mouth)) {
		fragColor = mouth.color;
	}

	vec2 tongueSpace = mouthSpace;
	tongueSpace -= tongue.pos;
	tongueSpace = rotate2D(tongue.rot) * tongueSpace;
	tongueSpace = scale2D(tongue.scale) * tongueSpace;
	tongueSpace += tongue.pos;
	if (false ^^ CircleCheck(tongueSpace, tongue)) {
		fragColor = tongue.color;
	}

	vec2 eyeBrow1Space = fragCoord;
	eyeBrow1Space -= eyeBrow1.pos;
	eyeBrow1Space = rotate2D(eyeBrow1.rot) * eyeBrow1Space;
	eyeBrow1Space = scale2D(eyeBrow1.scale) * eyeBrow1Space;
	eyeBrow1Space += eyeBrow1.pos;
	if (false ^^ PolygonCheck(eyeBrow1Space, eyeBrow1, 5)) {
		fragColor = eyeBrow1.color;
	}

	vec2 eyeBrow2Space = fragCoord;
	eyeBrow2Space -= eyeBrow2.pos;
	eyeBrow2Space = rotate2D(eyeBrow2.rot) * eyeBrow2Space;
	eyeBrow2Space = scale2D(eyeBrow2.scale) * eyeBrow2Space;
	eyeBrow2Space += eyeBrow2.pos;
	if (false ^^ PolygonCheck(eyeBrow2Space, eyeBrow2, 5)) {
		fragColor = eyeBrow2.color;
	}

	vec2 eyeBrowFix1Space = fragCoord;
	eyeBrowFix1Space -= eyeBrowFix1.pos;
	eyeBrowFix1Space = rotate2D(eyeBrowFix1.rot) * eyeBrowFix1Space;
	eyeBrowFix1Space = scale2D(eyeBrowFix1.scale) * eyeBrowFix1Space;
	eyeBrowFix1Space += eyeBrowFix1.pos;
	if (false ^^ PolygonCheck(eyeBrowFix1Space, eyeBrowFix1, 3)) {
		fragColor = eyeBrowFix1.color;
	}

	vec2 eyeBrowFix2Space = fragCoord;
	eyeBrowFix2Space -= eyeBrowFix2.pos;
	eyeBrowFix2Space = rotate2D(eyeBrowFix2.rot) * eyeBrowFix2Space;
	eyeBrowFix2Space = scale2D(eyeBrowFix2.scale) * eyeBrowFix2Space;
	eyeBrowFix2Space += eyeBrowFix2.pos;
	if (false ^^ PolygonCheck(eyeBrowFix2Space, eyeBrowFix2, 3)) {
		fragColor = eyeBrowFix2.color;
	}

	vec2 hedSpace = fragCoord;
	hedSpace -= hed.pos;
	hedSpace = rotate2D(hed.rot) * hedSpace;
	hedSpace = scale2D(hed.scale) * hedSpace;
	hedSpace += hed.pos;
	if (false ^^ CircleCheck(hedSpace, hed)) {
		fragColor = hed.color;
	}

	vec2 top1Space = hedSpace;
	top1Space -= top1.pos;
	top1Space = rotate2D(top1.rot) * top1Space;
	top1Space = scale2D(top1.scale) * top1Space;
	top1Space += top1.pos;
	if (false ^^ CircleCheck(top1Space, top1)) {
		fragColor = top1.color;
	}

	vec2 top2Space = hedSpace;
	top2Space -= top2.pos;
	top2Space = rotate2D(top2.rot) * top2Space;
	top2Space = scale2D(top2.scale) * top2Space;
	top2Space += top2.pos;
	if (false ^^ CircleCheck(top2Space, top2)) {
		fragColor = top2.color;
	}

	vec2 moufSpace = hedSpace;
	moufSpace -= mouf.pos;
	moufSpace = rotate2D(mouf.rot) * moufSpace;
	moufSpace = scale2D(mouf.scale) * moufSpace;
	moufSpace += mouf.pos;
	if (false ^^ CircleCheck(moufSpace, mouf)) {
		fragColor = mouf.color;
	}

	vec2 tip1Space = hedSpace;
	tip1Space -= tip1.pos;
	tip1Space = rotate2D(tip1.rot) * tip1Space;
	tip1Space = scale2D(tip1.scale) * tip1Space;
	tip1Space += tip1.pos;
	if (false ^^ CircleCheck(tip1Space, tip1)) {
		fragColor = tip1.color;
	}

	vec2 tip2Space = hedSpace;
	tip2Space -= tip2.pos;
	tip2Space = rotate2D(tip2.rot) * tip2Space;
	tip2Space = scale2D(tip2.scale) * tip2Space;
	tip2Space += tip2.pos;
	if (false ^^ CircleCheck(tip2Space, tip2)) {
		fragColor = tip2.color;
	}

	vec2 tip3Space = hedSpace;
	tip3Space -= tip3.pos;
	tip3Space = rotate2D(tip3.rot) * tip3Space;
	tip3Space = scale2D(tip3.scale) * tip3Space;
	tip3Space += tip3.pos;
	if (false ^^ CircleCheck(tip3Space, tip3)) {
		fragColor = tip3.color;
	}

	vec2 tip4Space = hedSpace;
	tip4Space -= tip4.pos;
	tip4Space = rotate2D(tip4.rot) * tip4Space;
	tip4Space = scale2D(tip4.scale) * tip4Space;
	tip4Space += tip4.pos;
	if (false ^^ CircleCheck(tip4Space, tip4)) {
		fragColor = tip4.color;
	}

	vec2 tip5Space = hedSpace;
	tip5Space -= tip5.pos;
	tip5Space = rotate2D(tip5.rot) * tip5Space;
	tip5Space = scale2D(tip5.scale) * tip5Space;
	tip5Space += tip5.pos;
	if (false ^^ CircleCheck(tip5Space, tip5)) {
		fragColor = tip5.color;
	}

	vec2 eye1Space = hedSpace;
	eye1Space -= eye1.pos;
	eye1Space = rotate2D(eye1.rot) * eye1Space;
	eye1Space = scale2D(eye1.scale) * eye1Space;
	eye1Space += eye1.pos;
	if (false ^^ CircleCheck(eye1Space, eye1)) {
		fragColor = eye1.color;
	}

	vec2 eye2Space = hedSpace;
	eye2Space -= eye2.pos;
	eye2Space = rotate2D(eye2.rot) * eye2Space;
	eye2Space = scale2D(eye2.scale) * eye2Space;
	eye2Space += eye2.pos;
	if (false ^^ CircleCheck(eye2Space, eye2)) {
		fragColor = eye2.color;
	}

	vec2 moufHoleSpace = hedSpace;
	moufHoleSpace -= moufHole.pos;
	moufHoleSpace = rotate2D(moufHole.rot) * moufHoleSpace;
	moufHoleSpace = scale2D(moufHole.scale) * moufHoleSpace;
	moufHoleSpace += moufHole.pos;
	if (false ^^ CircleCheck(moufHoleSpace, moufHole)) {
		fragColor = moufHole.color;
	}

	vec2 rec1Space = fragCoord;
	rec1Space -= rec1.pos;
	rec1Space = rotate2D(rec1.rot) * rec1Space;
	rec1Space = scale2D(rec1.scale) * rec1Space;
	rec1Space += rec1.pos;
	if (false ^^ RectangleCheck(rec1Space, rec1)) {
		fragColor = rec1.color;
	}

	vec2 rec2Space = rec1Space;
	rec2Space -= rec2.pos;
	rec2Space = rotate2D(rec2.rot) * rec2Space;
	rec2Space = scale2D(rec2.scale) * rec2Space;
	rec2Space += rec2.pos;
	if (false ^^ RectangleCheck(rec2Space, rec2)) {
		fragColor = rec2.color;
	}

	vec2 rec3Space = rec2Space;
	rec3Space -= rec3.pos;
	rec3Space = rotate2D(rec3.rot) * rec3Space;
	rec3Space = scale2D(rec3.scale) * rec3Space;
	rec3Space += rec3.pos;
	if (false ^^ RectangleCheck(rec3Space, rec3)) {
		fragColor = rec3.color;
	}

	vec2 rec4Space = rec3Space;
	rec4Space -= rec4.pos;
	rec4Space = rotate2D(rec4.rot) * rec4Space;
	rec4Space = scale2D(rec4.scale) * rec4Space;
	rec4Space += rec4.pos;
	if (false ^^ RectangleCheck(rec4Space, rec4)) {
		fragColor = rec4.color;
	}

	vec2 rec5Space = rec4Space;
	rec5Space -= rec5.pos;
	rec5Space = rotate2D(rec5.rot) * rec5Space;
	rec5Space = scale2D(rec5.scale) * rec5Space;
	rec5Space += rec5.pos;
	if (false ^^ RectangleCheck(rec5Space, rec5)) {
		fragColor = rec5.color;
	}

	vec2 circle5Space = rec5Space;
	circle5Space -= circle5.pos;
	circle5Space = rotate2D(circle5.rot) * circle5Space;
	circle5Space = scale2D(circle5.scale) * circle5Space;
	circle5Space += circle5.pos;
	if (false ^^ CircleCheck(circle5Space, circle5)) {
		fragColor = circle5.color;
	}

	vec2 circle4Space = rec4Space;
	circle4Space -= circle4.pos;
	circle4Space = rotate2D(circle4.rot) * circle4Space;
	circle4Space = scale2D(circle4.scale) * circle4Space;
	circle4Space += circle4.pos;
	if (false ^^ CircleCheck(circle4Space, circle4)) {
		fragColor = circle4.color;
	}

	vec2 circle3Space = rec3Space;
	circle3Space -= circle3.pos;
	circle3Space = rotate2D(circle3.rot) * circle3Space;
	circle3Space = scale2D(circle3.scale) * circle3Space;
	circle3Space += circle3.pos;
	if (false ^^ CircleCheck(circle3Space, circle3)) {
		fragColor = circle3.color;
	}

	vec2 circle2Space = rec2Space;
	circle2Space -= circle2.pos;
	circle2Space = rotate2D(circle2.rot) * circle2Space;
	circle2Space = scale2D(circle2.scale) * circle2Space;
	circle2Space += circle2.pos;
	if (false ^^ CircleCheck(circle2Space, circle2)) {
		fragColor = circle2.color;
	}

	vec2 circle1Space = rec1Space;
	circle1Space -= circle1.pos;
	circle1Space = rotate2D(circle1.rot) * circle1Space;
	circle1Space = scale2D(circle1.scale) * circle1Space;
	circle1Space += circle1.pos;
	if (false ^^ CircleCheck(circle1Space, circle1)) {
		fragColor = circle1.color;
	}

	vec2 polySpace = fragCoord;
	polySpace -= poly.pos;
	polySpace = rotate2D(poly.rot) * polySpace;
	polySpace = scale2D(poly.scale) * polySpace;
	polySpace += poly.pos;
	if (false ^^ PolygonCheck(polySpace, poly, 4)) {
		fragColor = poly.color;
	}

}

bool CircleCheck(vec2 point, Circle circle){
	return (distance(point, circle.pos) < circle.radius);
}

bool RectangleCheck(vec2 point, Rectangle rec){
	return (point.x > rec.pos.x - rec.size.x * 0.5 && point.x < rec.pos.x + rec.size.x * 0.5 &&
			point.y > rec.pos.y - rec.size.y * 0.5 && point.y < rec.pos.y + rec.size.y * 0.5);
}

bool PolygonCheck(vec2 point, Polygon poly, int amt){
	    float angle = 0.0;
    for (int i = 0; i < amt; i++) {
        vec2 a = vec2(poly.points[i]-point+poly.pos);
        
        vec2 b;
        
        if (i < amt-1)
        	b = vec2(poly.points[i+1]-point+poly.pos);
        else
            b = vec2(poly.points[0]-point+poly.pos);
        
        angle += abs( acos( dot(a,b) / ( length(a) * length(b) ) ) );
    }
    angle *= 180.0 / PI;
    return angle < 361.0 && angle > 359.0;
}

mat2 rotate2D(float angle){
	float rad = -angle * PI / 180.0;
	return mat2(cos(rad), -sin(rad), sin(rad), cos(rad));
}

mat2 scale2D(vec2 scale){
	return mat2(1.0/scale.x, 0.0, 0.0, 1.0/scale.y);
}


  </script>
  
  
  <!-- TWGL -->
  
  <script src="js/twgl.min.js"></script>
  <script>
    "use strict";
    const gl = twgl.getContext(document.getElementById("c"));
    console.log("using:" + gl.getParameter(gl.VERSION));  // eslint-disable-line
    if (!twgl.isWebGL2(gl)) {
        alert("Sorry, this shader requires WebGL 2.0");  // eslint-disable-line
    }
    
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    const arrays = {
      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
    };
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    requestAnimationFrame(render);
    
    function render(time) {
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const uniforms = {
        iTime: time * 0.001,
        iResolution: [gl.canvas.width, gl.canvas.height],
      };

      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, bufferInfo);

      requestAnimationFrame(render);
    }
  </script>
</html>