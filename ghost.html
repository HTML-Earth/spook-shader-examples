<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>Ghost.spook</title>
    <style>
      body {
          margin: 0;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>


  <!-- VERTEX -->
  
  <script id="vs" type="notjs">
#version 300 es
in vec4 position;

void main() {
  gl_Position = position;
}
  </script>



  <!-- FRAGMENT -->

  <script id="fs" type="notjs">#version 300 es
// Ghost.spook
// Compiled with Spook Compiler 
// https://github.com/HTML-Earth/Spook-Compiler

precision mediump float;

out vec4 fragColor;

uniform vec2 iResolution;
uniform float iTime;

const float PI = 3.1415926535897932384626433832795;

struct Circle {
	float radius;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};

bool CircleCheck(vec2 point, Circle circle);
mat2 rotate2D(float angle);
mat2 scale2D(vec2 scale);

void main() {
vec2 fragCoord = gl_FragCoord.xy;
	// Variable Declarations
	float sway = sin(iTime*0.20000000298023224)*50.0;

	float hover = sin(iTime)*15.0;

	float xPos = 50.0+sway;

	float yPos = 20.0+hover;

	float i = 0.0;

	float frac = i*(1.0/5.0);

	float hoverTips = sin(iTime)*-5.0;

	float i_v1 = 1.0;

	float frac_v1 = i_v1*(1.0/5.0);

	float i_v2 = 2.0;

	float frac_v2 = i_v2*(1.0/5.0);

	float i_v3 = 3.0;

	float frac_v3 = i_v3*(1.0/5.0);

	float i_v4 = 4.0;

	float frac_v4 = i_v4*(1.0/5.0);

	float swayFace = -sin(iTime*0.20000000298023224-2.0)*-8.0;

	float hoverEyes = sin(iTime-0.10000000149011612)*5.0;

	float hoverMouf = sin(iTime-0.20000000298023224)*10.0;

	// Object Declarations
	Circle top1 = Circle(
		40.0,
		vec2(xPos+130.0+0.0, yPos+250.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle top2 = Circle(
		40.0,
		vec2(xPos+100.0+0.0, yPos+240.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle hed = Circle(
		80.0,
		vec2(xPos+100.0+0.0, yPos+190.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle mouf = Circle(
		90.0,
		vec2(xPos+150.0+0.0, yPos+130.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip = Circle(
		15.0,
		vec2(xPos+200.0+sin(frac-1.0)*150.0+0.0, yPos+128.0-cos(frac*1.5-1.0)*90.0+hoverTips+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip_v1 = Circle(
		15.0,
		vec2(xPos+200.0+sin(frac_v1-1.0)*150.0+0.0, yPos+128.0-cos(frac_v1*1.5-1.0)*90.0+hoverTips+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip_v2 = Circle(
		15.0,
		vec2(xPos+200.0+sin(frac_v2-1.0)*150.0+0.0, yPos+128.0-cos(frac_v2*1.5-1.0)*90.0+hoverTips+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip_v3 = Circle(
		15.0,
		vec2(xPos+200.0+sin(frac_v3-1.0)*150.0+0.0, yPos+128.0-cos(frac_v3*1.5-1.0)*90.0+hoverTips+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle tip_v4 = Circle(
		15.0,
		vec2(xPos+200.0+sin(frac_v4-1.0)*150.0+0.0, yPos+128.0-cos(frac_v4*1.5-1.0)*90.0+hoverTips+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle eye1 = Circle(
		20.0,
		vec2(xPos+100.0+swayFace+0.0, yPos+220.0+hoverEyes+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle eye2 = Circle(
		15.0,
		vec2(xPos+140.0+swayFace+0.0, yPos+230.0+hoverEyes+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle moufHole = Circle(
		35.0,
		vec2(xPos+190.0+swayFace+0.0, yPos+130.0+hoverMouf+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	// Checks and Drawing
	fragColor = vec4(0.0, 0.0, 0.0, 1.0);


	vec2 top1Space = fragCoord;
	top1Space -= top1.pos;
	top1Space = rotate2D(top1.rot) * top1Space;
	top1Space = scale2D(top1.scale) * top1Space;
	top1Space += top1.pos;
	if (false ^^ CircleCheck(top1Space, top1)) {
		fragColor = top1.color;
	}

	vec2 top2Space = fragCoord;
	top2Space -= top2.pos;
	top2Space = rotate2D(top2.rot) * top2Space;
	top2Space = scale2D(top2.scale) * top2Space;
	top2Space += top2.pos;
	if (false ^^ CircleCheck(top2Space, top2)) {
		fragColor = top2.color;
	}

	vec2 hedSpace = fragCoord;
	hedSpace -= hed.pos;
	hedSpace = rotate2D(hed.rot) * hedSpace;
	hedSpace = scale2D(hed.scale) * hedSpace;
	hedSpace += hed.pos;
	if (false ^^ CircleCheck(hedSpace, hed)) {
		fragColor = hed.color;
	}

	vec2 moufSpace = fragCoord;
	moufSpace -= mouf.pos;
	moufSpace = rotate2D(mouf.rot) * moufSpace;
	moufSpace = scale2D(mouf.scale) * moufSpace;
	moufSpace += mouf.pos;
	if (false ^^ CircleCheck(moufSpace, mouf)) {
		fragColor = mouf.color;
	}

	vec2 tipSpace = fragCoord;
	tipSpace -= tip.pos;
	tipSpace = rotate2D(tip.rot) * tipSpace;
	tipSpace = scale2D(tip.scale) * tipSpace;
	tipSpace += tip.pos;
	if (false ^^ CircleCheck(tipSpace, tip)) {
		fragColor = tip.color;
	}

	vec2 tip_v1Space = fragCoord;
	tip_v1Space -= tip_v1.pos;
	tip_v1Space = rotate2D(tip_v1.rot) * tip_v1Space;
	tip_v1Space = scale2D(tip_v1.scale) * tip_v1Space;
	tip_v1Space += tip_v1.pos;
	if (false ^^ CircleCheck(tip_v1Space, tip_v1)) {
		fragColor = tip_v1.color;
	}

	vec2 tip_v2Space = fragCoord;
	tip_v2Space -= tip_v2.pos;
	tip_v2Space = rotate2D(tip_v2.rot) * tip_v2Space;
	tip_v2Space = scale2D(tip_v2.scale) * tip_v2Space;
	tip_v2Space += tip_v2.pos;
	if (false ^^ CircleCheck(tip_v2Space, tip_v2)) {
		fragColor = tip_v2.color;
	}

	vec2 tip_v3Space = fragCoord;
	tip_v3Space -= tip_v3.pos;
	tip_v3Space = rotate2D(tip_v3.rot) * tip_v3Space;
	tip_v3Space = scale2D(tip_v3.scale) * tip_v3Space;
	tip_v3Space += tip_v3.pos;
	if (false ^^ CircleCheck(tip_v3Space, tip_v3)) {
		fragColor = tip_v3.color;
	}

	vec2 tip_v4Space = fragCoord;
	tip_v4Space -= tip_v4.pos;
	tip_v4Space = rotate2D(tip_v4.rot) * tip_v4Space;
	tip_v4Space = scale2D(tip_v4.scale) * tip_v4Space;
	tip_v4Space += tip_v4.pos;
	if (false ^^ CircleCheck(tip_v4Space, tip_v4)) {
		fragColor = tip_v4.color;
	}

	vec2 eye1Space = fragCoord;
	eye1Space -= eye1.pos;
	eye1Space = rotate2D(eye1.rot) * eye1Space;
	eye1Space = scale2D(eye1.scale) * eye1Space;
	eye1Space += eye1.pos;
	if (false ^^ CircleCheck(eye1Space, eye1)) {
		fragColor = eye1.color;
	}

	vec2 eye2Space = fragCoord;
	eye2Space -= eye2.pos;
	eye2Space = rotate2D(eye2.rot) * eye2Space;
	eye2Space = scale2D(eye2.scale) * eye2Space;
	eye2Space += eye2.pos;
	if (false ^^ CircleCheck(eye2Space, eye2)) {
		fragColor = eye2.color;
	}

	vec2 moufHoleSpace = fragCoord;
	moufHoleSpace -= moufHole.pos;
	moufHoleSpace = rotate2D(moufHole.rot) * moufHoleSpace;
	moufHoleSpace = scale2D(moufHole.scale) * moufHoleSpace;
	moufHoleSpace += moufHole.pos;
	if (false ^^ CircleCheck(moufHoleSpace, moufHole)) {
		fragColor = moufHole.color;
	}

}

bool CircleCheck(vec2 point, Circle circle){
	return (distance(point, circle.pos) < circle.radius);
}

mat2 rotate2D(float angle){
	float rad = -angle * PI / 180.0;
	return mat2(cos(rad), -sin(rad), sin(rad), cos(rad));
}

mat2 scale2D(vec2 scale){
	return mat2(1.0/scale.x, 0.0, 0.0, 1.0/scale.y);
}


  </script>
  
  
  <!-- TWGL -->
  
  <script src="js/twgl.min.js"></script>
  <script>
    "use strict";
    const gl = twgl.getContext(document.getElementById("c"));
    console.log("using:" + gl.getParameter(gl.VERSION));  // eslint-disable-line
    if (!twgl.isWebGL2(gl)) {
        alert("Sorry, this shader requires WebGL 2.0");  // eslint-disable-line
    }
    
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    const arrays = {
      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
    };
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    requestAnimationFrame(render);
    
    function render(time) {
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const uniforms = {
        iTime: time * 0.001,
        iResolution: [gl.canvas.width, gl.canvas.height],
      };

      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, bufferInfo);

      requestAnimationFrame(render);
    }
  </script>
</html>