<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>FunnyShader.spook</title>
    <style>
      body {
          margin: 0;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>


  <!-- VERTEX -->
  
  <script id="vs" type="notjs">
#version 300 es
in vec4 position;

void main() {
  gl_Position = position;
}
  </script>



  <!-- FRAGMENT -->

  <script id="fs" type="notjs">#version 300 es
// FunnyShader.spook
// Compiled with Spook Compiler 
// https://github.com/HTML-Earth/Spook-Compiler

precision mediump float;

out vec4 fragColor;

uniform vec2 iResolution;
uniform float iTime;

const float PI = 3.1415926535897932384626433832795;

struct Circle {
	float radius;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};
struct Rectangle {
	vec2 size;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};
struct Polygon {
	vec2 points[16];
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};

bool CircleCheck(vec2 point, Circle circle);
bool RectangleCheck(vec2 point, Rectangle rec);
bool PolygonCheck(vec2 point, Polygon poly, int amt);
mat2 rotate2D(float angle);
mat2 scale2D(vec2 scale);

void main() {
vec2 fragCoord = gl_FragCoord.xy;
	// Variable Declarations
	float xPos = iResolution.x/2.0;

	float yPos = iResolution.y/2.0;

	vec4 whiteTransparent = vec4(1.0, 1.0, 1.0, 0.5);

	float blinkMove = sin(iTime)*80.0;

	vec2 point1 = vec2(0.0, 0.0);

	vec2 point3 = vec2(250.0, 0.0);

	vec2 point4 = vec2(250.0, 25.0);

	vec2 point5 = vec2(125.0, 60.0);

	vec2 point6 = vec2(0.0, 25.0);

	vec2 point2 = vec2(125.0, 10.0);

	// Object Declarations
	Circle bag1 = Circle(
		100.0,
		vec2(xPos-150.0+0.0+0.0, yPos-10.0+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Circle bag2 = Circle(
		100.0,
		vec2(xPos+150.0+0.0+0.0, yPos-10.0+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Circle shine1 = Circle(
		30.0,
		vec2(20.0+20.0+cos(iTime)*20.0+xPos-150.0+0.0+0.0, 30.0+sin(iTime)*20.0+yPos+0.0+0.0),
		vec2(0.5, 1.0),
		0.0,
		vec4(whiteTransparent)
	);

	Circle circleEye1 = Circle(
		55.0,
		vec2(20.0+cos(iTime)*20.0+xPos-150.0+0.0+0.0, sin(iTime)*20.0+yPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle circle1 = Circle(
		100.0,
		vec2(xPos-150.0+0.0+0.0, yPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle shine2 = Circle(
		30.0,
		vec2(20.0+-20.0+cos(iTime)*20.0+xPos+150.0+0.0+0.0, 30.0+sin(iTime)*20.0+yPos+0.0+0.0),
		vec2(0.5, 1.0),
		0.0,
		vec4(whiteTransparent)
	);

	Circle circleEye2 = Circle(
		55.0,
		vec2(-20.0+cos(iTime)*20.0+xPos+150.0+0.0+0.0, sin(iTime)*20.0+yPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Circle circle2 = Circle(
		100.0,
		vec2(xPos+150.0+0.0+0.0, yPos+0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 1.0, 1.0, 1.0)
	);

	Circle middle = Circle(
		10.0,
		vec2(0.0+0.0, 0.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 0.0)
	);

	Rectangle eyelid1 = Rectangle(
		vec2(200.0, 300.0),
		vec2(150.0+xPos+0.0, 0.0+yPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Rectangle eyelid2 = Rectangle(
		vec2(200.0, 300.0),
		vec2(-150.0+xPos+0.0, 0.0+yPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Rectangle rec1 = Rectangle(
		vec2(200.0, 305.0),
		vec2(150.0+xPos+0.0, 15.0+yPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Rectangle rec2 = Rectangle(
		vec2(200.0, 305.0),
		vec2(-150.0+xPos+0.0, 15.0+yPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Circle mover = Circle(
		10.0,
		vec2(xPos+0.0, yPos+120.0+blinkMove+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.0, 0.0, 0.0, 0.0)
	);

	Circle tongue = Circle(
		30.0,
		vec2(0.0+xPos+0.0, -35.0+yPos-120.0+0.0),
		vec2(1.0, 0.6000000238418579),
		0.0,
		vec4(1.0, 0.0, 0.0, 1.0)
	);

	Circle mouth = Circle(
		50.0,
		vec2(xPos+0.0, yPos-120.0+0.0),
		vec2(1.0, 0.4000000059604645),
		0.0,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	Polygon eyeBrow1 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(250.0, 25.0),
			vec2(125.0, 60.0),
			vec2(0.0, 25.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(xPos-275.0+0.0, yPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Polygon eyeBrow2 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(250.0, 25.0),
			vec2(125.0, 60.0),
			vec2(0.0, 25.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(xPos+25.0+0.0, yPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(0.5, 0.0, 0.5, 1.0)
	);

	Polygon eyeBrowFix1 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(125.0, 10.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(xPos-275.0+0.0, yPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	Polygon eyeBrowFix2 = Polygon(
		vec2[16](
			vec2(0.0, 0.0),
			vec2(250.0, 0.0),
			vec2(125.0, 10.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0),
			vec2(0.0, 0.0)
		),
		vec2(xPos+25.0+0.0, yPos+100.0+0.0),
		vec2(1.0, 1.0),
		0.0,
		vec4(1.0, 0.0, 1.0, 1.0)
	);

	// Checks and Drawing
	fragColor = vec4(1.0, 0.0, 1.0, 1.0);


	vec2 middleSpace = fragCoord;
	middleSpace -= middle.pos;
	middleSpace = rotate2D(middle.rot) * middleSpace;
	middleSpace = scale2D(middle.scale) * middleSpace;
	middleSpace += middle.pos;
	if (false ^^ CircleCheck(middleSpace, middle)) {
		fragColor = mix(fragColor, middle.color, middle.color.a);
	}

	vec2 bag1Space = middleSpace;
	bag1Space -= bag1.pos;
	bag1Space = rotate2D(bag1.rot) * bag1Space;
	bag1Space = scale2D(bag1.scale) * bag1Space;
	bag1Space += bag1.pos;
	if (false ^^ CircleCheck(bag1Space, bag1)) {
		fragColor = bag1.color;
	}

	vec2 bag2Space = middleSpace;
	bag2Space -= bag2.pos;
	bag2Space = rotate2D(bag2.rot) * bag2Space;
	bag2Space = scale2D(bag2.scale) * bag2Space;
	bag2Space += bag2.pos;
	if (false ^^ CircleCheck(bag2Space, bag2)) {
		fragColor = bag2.color;
	}

	vec2 circle1Space = middleSpace;
	circle1Space -= circle1.pos;
	circle1Space = rotate2D(circle1.rot) * circle1Space;
	circle1Space = scale2D(circle1.scale) * circle1Space;
	circle1Space += circle1.pos;
	if (false ^^ CircleCheck(circle1Space, circle1)) {
		fragColor = circle1.color;
	}

	vec2 circleEye1Space = circle1Space;
	circleEye1Space -= circleEye1.pos;
	circleEye1Space = rotate2D(circleEye1.rot) * circleEye1Space;
	circleEye1Space = scale2D(circleEye1.scale) * circleEye1Space;
	circleEye1Space += circleEye1.pos;
	if (false ^^ CircleCheck(circleEye1Space, circleEye1)) {
		fragColor = circleEye1.color;
	}

	vec2 shine1Space = circleEye1Space;
	shine1Space -= shine1.pos;
	shine1Space = rotate2D(shine1.rot) * shine1Space;
	shine1Space = scale2D(shine1.scale) * shine1Space;
	shine1Space += shine1.pos;
	if (false ^^ CircleCheck(shine1Space, shine1)) {
		fragColor = mix(fragColor, shine1.color, shine1.color.a);
	}

	vec2 circle2Space = middleSpace;
	circle2Space -= circle2.pos;
	circle2Space = rotate2D(circle2.rot) * circle2Space;
	circle2Space = scale2D(circle2.scale) * circle2Space;
	circle2Space += circle2.pos;
	if (false ^^ CircleCheck(circle2Space, circle2)) {
		fragColor = circle2.color;
	}

	vec2 circleEye2Space = circle2Space;
	circleEye2Space -= circleEye2.pos;
	circleEye2Space = rotate2D(circleEye2.rot) * circleEye2Space;
	circleEye2Space = scale2D(circleEye2.scale) * circleEye2Space;
	circleEye2Space += circleEye2.pos;
	if (false ^^ CircleCheck(circleEye2Space, circleEye2)) {
		fragColor = circleEye2.color;
	}

	vec2 shine2Space = circleEye2Space;
	shine2Space -= shine2.pos;
	shine2Space = rotate2D(shine2.rot) * shine2Space;
	shine2Space = scale2D(shine2.scale) * shine2Space;
	shine2Space += shine2.pos;
	if (false ^^ CircleCheck(shine2Space, shine2)) {
		fragColor = mix(fragColor, shine2.color, shine2.color.a);
	}

	vec2 moverSpace = fragCoord;
	moverSpace -= mover.pos;
	moverSpace = rotate2D(mover.rot) * moverSpace;
	moverSpace = scale2D(mover.scale) * moverSpace;
	moverSpace += mover.pos;
	if (false ^^ CircleCheck(moverSpace, mover)) {
		fragColor = mix(fragColor, mover.color, mover.color.a);
	}

	vec2 eyelid1Space = moverSpace;
	eyelid1Space -= eyelid1.pos;
	eyelid1Space = rotate2D(eyelid1.rot) * eyelid1Space;
	eyelid1Space = scale2D(eyelid1.scale) * eyelid1Space;
	eyelid1Space += eyelid1.pos;
	if (false ^^ RectangleCheck(eyelid1Space, eyelid1)) {
		fragColor = eyelid1.color;
	}

	vec2 eyelid2Space = moverSpace;
	eyelid2Space -= eyelid2.pos;
	eyelid2Space = rotate2D(eyelid2.rot) * eyelid2Space;
	eyelid2Space = scale2D(eyelid2.scale) * eyelid2Space;
	eyelid2Space += eyelid2.pos;
	if (false ^^ RectangleCheck(eyelid2Space, eyelid2)) {
		fragColor = eyelid2.color;
	}

	vec2 rec1Space = moverSpace;
	rec1Space -= rec1.pos;
	rec1Space = rotate2D(rec1.rot) * rec1Space;
	rec1Space = scale2D(rec1.scale) * rec1Space;
	rec1Space += rec1.pos;
	if (false ^^ RectangleCheck(rec1Space, rec1)) {
		fragColor = rec1.color;
	}

	vec2 rec2Space = moverSpace;
	rec2Space -= rec2.pos;
	rec2Space = rotate2D(rec2.rot) * rec2Space;
	rec2Space = scale2D(rec2.scale) * rec2Space;
	rec2Space += rec2.pos;
	if (false ^^ RectangleCheck(rec2Space, rec2)) {
		fragColor = rec2.color;
	}

	vec2 mouthSpace = fragCoord;
	mouthSpace -= mouth.pos;
	mouthSpace = rotate2D(mouth.rot) * mouthSpace;
	mouthSpace = scale2D(mouth.scale) * mouthSpace;
	mouthSpace += mouth.pos;
	if (false ^^ CircleCheck(mouthSpace, mouth)) {
		fragColor = mouth.color;
	}

	vec2 tongueSpace = mouthSpace;
	tongueSpace -= tongue.pos;
	tongueSpace = rotate2D(tongue.rot) * tongueSpace;
	tongueSpace = scale2D(tongue.scale) * tongueSpace;
	tongueSpace += tongue.pos;
	if (false ^^ CircleCheck(tongueSpace, tongue)) {
		fragColor = tongue.color;
	}

	vec2 eyeBrow1Space = fragCoord;
	eyeBrow1Space -= eyeBrow1.pos;
	eyeBrow1Space = rotate2D(eyeBrow1.rot) * eyeBrow1Space;
	eyeBrow1Space = scale2D(eyeBrow1.scale) * eyeBrow1Space;
	eyeBrow1Space += eyeBrow1.pos;
	if (false ^^ PolygonCheck(eyeBrow1Space, eyeBrow1, 5)) {
		fragColor = eyeBrow1.color;
	}

	vec2 eyeBrow2Space = fragCoord;
	eyeBrow2Space -= eyeBrow2.pos;
	eyeBrow2Space = rotate2D(eyeBrow2.rot) * eyeBrow2Space;
	eyeBrow2Space = scale2D(eyeBrow2.scale) * eyeBrow2Space;
	eyeBrow2Space += eyeBrow2.pos;
	if (false ^^ PolygonCheck(eyeBrow2Space, eyeBrow2, 5)) {
		fragColor = eyeBrow2.color;
	}

	vec2 eyeBrowFix1Space = fragCoord;
	eyeBrowFix1Space -= eyeBrowFix1.pos;
	eyeBrowFix1Space = rotate2D(eyeBrowFix1.rot) * eyeBrowFix1Space;
	eyeBrowFix1Space = scale2D(eyeBrowFix1.scale) * eyeBrowFix1Space;
	eyeBrowFix1Space += eyeBrowFix1.pos;
	if (false ^^ PolygonCheck(eyeBrowFix1Space, eyeBrowFix1, 3)) {
		fragColor = eyeBrowFix1.color;
	}

	vec2 eyeBrowFix2Space = fragCoord;
	eyeBrowFix2Space -= eyeBrowFix2.pos;
	eyeBrowFix2Space = rotate2D(eyeBrowFix2.rot) * eyeBrowFix2Space;
	eyeBrowFix2Space = scale2D(eyeBrowFix2.scale) * eyeBrowFix2Space;
	eyeBrowFix2Space += eyeBrowFix2.pos;
	if (false ^^ PolygonCheck(eyeBrowFix2Space, eyeBrowFix2, 3)) {
		fragColor = eyeBrowFix2.color;
	}

}

bool CircleCheck(vec2 point, Circle circle){
	return (distance(point, circle.pos) < circle.radius);
}

bool RectangleCheck(vec2 point, Rectangle rec){
	return (point.x > rec.pos.x - rec.size.x * 0.5 && point.x < rec.pos.x + rec.size.x * 0.5 &&
			point.y > rec.pos.y - rec.size.y * 0.5 && point.y < rec.pos.y + rec.size.y * 0.5);
}

bool PolygonCheck(vec2 point, Polygon poly, int amt){
	    float angle = 0.0;
    for (int i = 0; i < amt; i++) {
        vec2 a = vec2(poly.points[i]-point+poly.pos);
        
        vec2 b;
        
        if (i < amt-1)
        	b = vec2(poly.points[i+1]-point+poly.pos);
        else
            b = vec2(poly.points[0]-point+poly.pos);
        
        angle += abs( acos( dot(a,b) / ( length(a) * length(b) ) ) );
    }
    angle *= 180.0 / PI;
    return angle < 361.0 && angle > 359.0;
}

mat2 rotate2D(float angle){
	float rad = -angle * PI / 180.0;
	return mat2(cos(rad), -sin(rad), sin(rad), cos(rad));
}

mat2 scale2D(vec2 scale){
	return mat2(1.0/scale.x, 0.0, 0.0, 1.0/scale.y);
}


  </script>
  
  
  <!-- TWGL -->
  
  <script src="js/twgl.min.js"></script>
  <script>
    "use strict";
    const gl = twgl.getContext(document.getElementById("c"));
    console.log("using:" + gl.getParameter(gl.VERSION));  // eslint-disable-line
    if (!twgl.isWebGL2(gl)) {
        alert("Sorry, this shader requires WebGL 2.0");  // eslint-disable-line
    }
    
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    const arrays = {
      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
    };
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    requestAnimationFrame(render);
    
    function render(time) {
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const uniforms = {
        iTime: time * 0.001,
        iResolution: [gl.canvas.width, gl.canvas.height],
      };

      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, bufferInfo);

      requestAnimationFrame(render);
    }
  </script>
</html>