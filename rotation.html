<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--

    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details

    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>RotationTest.spook</title>
    <style>
      body {
          margin: 0;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>


  <!-- VERTEX -->
  
  <script id="vs" type="notjs">
#version 300 es
in vec4 position;

void main() {
  gl_Position = position;
}
  </script>



  <!-- FRAGMENT -->

  <script id="fs" type="notjs">#version 300 es
// RotationTest.spook
// Compiled with Spook Compiler 
// https://github.com/HTML-Earth/Spook-Compiler

precision mediump float;

out vec4 fragColor;

uniform vec2 iResolution;
uniform float iTime;

const float PI = 3.1415926535897932384626433832795;

struct Circle {
	float radius;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};
struct Rectangle {
	vec2 size;
	vec2 pos;
	vec2 scale;
	float rot;
	vec4 color;
};

bool CircleCheck(vec2 point, Circle circle);
bool RectangleCheck(vec2 point, Rectangle rec);
mat2 rotate2D(float angle);
mat2 scale2D(vec2 scale);

void main() {
vec2 fragCoord = gl_FragCoord.xy;
	// Variable Declarations
	float rotation = sin(iTime)*15.0;

	float circleScale = max(sin(iTime*0.25), 0.25)*3.0;

	// Object Declarations
	Circle circle5 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+50.0+50.0+50.0+0.0, 50.0+50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec5 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+50.0+50.0+50.0+0.0, 50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle4 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+50.0+50.0+0.0, 50.0+50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec4 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+50.0+50.0+0.0, 50.0+50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle3 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+50.0+0.0, 50.0+50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec3 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+50.0+0.0, 50.0+50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle2 = Circle(
		25.0,
		vec2(50.0+50.0+50.0+0.0, 50.0+50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec2 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+50.0+0.0, 50.0+50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(1.0, 1.0, 0.0, 1.0)
	);

	Circle circle1 = Circle(
		25.0,
		vec2(50.0+50.0+0.0, 50.0+50.0+0.0),
		vec2(circleScale*sin(iTime), circleScale*cos(iTime)),
		0.0,
		vec4(0.0, 0.5, 0.5, 1.0)
	);

	Rectangle rec1 = Rectangle(
		vec2(50.0, 50.0),
		vec2(50.0+0.0, 50.0+0.0),
		vec2(1.0, 1.0),
		rotation,
		vec4(0.0, 0.0, 0.0, 1.0)
	);

	// Checks and Drawing
	fragColor = vec4(1.0, 0.0, 0.0, 1.0);


	vec2 rec1Space = fragCoord;
	rec1Space -= rec1.pos;
	rec1Space = rotate2D(rec1.rot) * rec1Space;
	rec1Space = scale2D(rec1.scale) * rec1Space;
	rec1Space += rec1.pos;
	if (false ^^ RectangleCheck(rec1Space, rec1)) {
		fragColor = rec1.color;
	}

	vec2 rec2Space = rec1Space;
	rec2Space -= rec2.pos;
	rec2Space = rotate2D(rec2.rot) * rec2Space;
	rec2Space = scale2D(rec2.scale) * rec2Space;
	rec2Space += rec2.pos;
	if (false ^^ RectangleCheck(rec2Space, rec2)) {
		fragColor = rec2.color;
	}

	vec2 rec3Space = rec2Space;
	rec3Space -= rec3.pos;
	rec3Space = rotate2D(rec3.rot) * rec3Space;
	rec3Space = scale2D(rec3.scale) * rec3Space;
	rec3Space += rec3.pos;
	if (false ^^ RectangleCheck(rec3Space, rec3)) {
		fragColor = rec3.color;
	}

	vec2 rec4Space = rec3Space;
	rec4Space -= rec4.pos;
	rec4Space = rotate2D(rec4.rot) * rec4Space;
	rec4Space = scale2D(rec4.scale) * rec4Space;
	rec4Space += rec4.pos;
	if (false ^^ RectangleCheck(rec4Space, rec4)) {
		fragColor = rec4.color;
	}

	vec2 rec5Space = rec4Space;
	rec5Space -= rec5.pos;
	rec5Space = rotate2D(rec5.rot) * rec5Space;
	rec5Space = scale2D(rec5.scale) * rec5Space;
	rec5Space += rec5.pos;
	if (false ^^ RectangleCheck(rec5Space, rec5)) {
		fragColor = rec5.color;
	}

	vec2 circle5Space = rec5Space;
	circle5Space -= circle5.pos;
	circle5Space = rotate2D(circle5.rot) * circle5Space;
	circle5Space = scale2D(circle5.scale) * circle5Space;
	circle5Space += circle5.pos;
	if (false ^^ CircleCheck(circle5Space, circle5)) {
		fragColor = circle5.color;
	}

	vec2 circle4Space = rec4Space;
	circle4Space -= circle4.pos;
	circle4Space = rotate2D(circle4.rot) * circle4Space;
	circle4Space = scale2D(circle4.scale) * circle4Space;
	circle4Space += circle4.pos;
	if (false ^^ CircleCheck(circle4Space, circle4)) {
		fragColor = circle4.color;
	}

	vec2 circle3Space = rec3Space;
	circle3Space -= circle3.pos;
	circle3Space = rotate2D(circle3.rot) * circle3Space;
	circle3Space = scale2D(circle3.scale) * circle3Space;
	circle3Space += circle3.pos;
	if (false ^^ CircleCheck(circle3Space, circle3)) {
		fragColor = circle3.color;
	}

	vec2 circle2Space = rec2Space;
	circle2Space -= circle2.pos;
	circle2Space = rotate2D(circle2.rot) * circle2Space;
	circle2Space = scale2D(circle2.scale) * circle2Space;
	circle2Space += circle2.pos;
	if (false ^^ CircleCheck(circle2Space, circle2)) {
		fragColor = circle2.color;
	}

	vec2 circle1Space = rec1Space;
	circle1Space -= circle1.pos;
	circle1Space = rotate2D(circle1.rot) * circle1Space;
	circle1Space = scale2D(circle1.scale) * circle1Space;
	circle1Space += circle1.pos;
	if (false ^^ CircleCheck(circle1Space, circle1)) {
		fragColor = circle1.color;
	}

}

bool CircleCheck(vec2 point, Circle circle){
	return (distance(point, circle.pos) < circle.radius);
}

bool RectangleCheck(vec2 point, Rectangle rec){
	return (point.x > rec.pos.x - rec.size.x * 0.5 && point.x < rec.pos.x + rec.size.x * 0.5 &&
			point.y > rec.pos.y - rec.size.y * 0.5 && point.y < rec.pos.y + rec.size.y * 0.5);
}

mat2 rotate2D(float angle){
	float rad = -angle * PI / 180.0;
	return mat2(cos(rad), -sin(rad), sin(rad), cos(rad));
}

mat2 scale2D(vec2 scale){
	return mat2(1.0/scale.x, 0.0, 0.0, 1.0/scale.y);
}


  </script>
  
  
  <!-- TWGL -->
  
  <script src="js/twgl.min.js"></script>
  <script>
    "use strict";
    const gl = twgl.getContext(document.getElementById("c"));
    console.log("using:" + gl.getParameter(gl.VERSION));  // eslint-disable-line
    if (!twgl.isWebGL2(gl)) {
        alert("Sorry, this shader requires WebGL 2.0");  // eslint-disable-line
    }
    
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    const arrays = {
      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
    };
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    requestAnimationFrame(render);
    
    function render(time) {
      twgl.resizeCanvasToDisplaySize(gl.canvas);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      const uniforms = {
        iTime: time * 0.001,
        iResolution: [gl.canvas.width, gl.canvas.height],
      };

      gl.useProgram(programInfo.program);
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, bufferInfo);

      requestAnimationFrame(render);
    }
  </script>
</html>